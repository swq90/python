##第 14 章　可迭代的对象、迭代器和生成器    
14.1　Sentence类第1版：单词序列 序列可以迭代的原因：iter函数 
14.2　可迭代的对象与迭代器的对比 14.3　Sentence类第2版：典型的迭代器 把Sentence变成迭代器：坏主意 14.4　Sentence类第3版：生成器函数 生成器函数的工作原理 14.5　Sentence类第4版：惰性实现 14.6　Sentence类第5版：生成器表达式 14.7　何时使用生成器表达式 14.8　另一个示例：等差数列生成器 使用itertools模块生成等差数列 14.9　标准库中的生成器函数 14.10　Python 3.3中新出现的句法：yield from 14.11　可迭代的归约函数 14.12　深入分析iter函数
14.13　案例分析：在数据库转换工具中使用生成器 1
4.14　把生成器当成协程 
14.15　本章小结 
14.16　延伸阅读 
第 15 章　上下文管理器和 else 块 
15.1　先做这个，再做那个：if语句之外的else块 15.2　上下文管理器和with块 15.3　contextlib模块中的实用工具 15.4　使用@contextmanager 15.5　本章小结 15.6　延伸阅读 第 16 章　协程 16.1　生成器如何进化成协程 16.2　用作协程的生成器的基本行为 16.3　示例：使用协程计算移动平均值 16.4　预激协程的装饰器 16.5　终止协程和异常处理 16.6　让协程返回值 16.7　使用yield from 16.8　yield from的意义 16.9　使用案例：使用协程做离散事件仿真 16.9.1　离散事件仿真简介 16.9.2　出租车队运营仿真 16.10　本章小结 16.11　延伸阅读 第 17 章　使用期物处理并发 17.1　示例：网络下载的三种风格 17.1.1　依序下载的脚本 17.1.2　使用concurrent.futures模块下载 17.1.3　期物在哪里 17.2　阻塞型I/O和GIL 17.3　使用concurrent.futures模块启动进程 17.4　实验Executor.map方法 17.5　显示下载进度并处理错误 17.5.1　flags2系列示例处理错误的方式 17.5.2　使用futures.as_completed函数
17.5.3　线程和多进程的替代方案 
17.6　本章小结 
17.7　延伸阅读 
第 18 章　使用 asyncio 包处理并发 
18.1　线程与协程对比 
18.1.1　asyncio.Future：故意不阻塞 
18.1.2　从期物、任务和协程中产出 
18.2　使用asyncio和aiohttp包下载 
18.3　避免阻塞型调用 
18.4　改进asyncio下载脚本 
18.4.1　使用asyncio.as_completed函数 
18.4.2　使用Executor对象，防止阻塞事件循环 
18.5　从回调到期物和协程 每次下载发起多次请求 
18.6　使用asyncio包编写服务器 
18.6.1　使用asyncio包编写TCP服务器 
18.6.2　使用aiohttp包编写Web服务器 
18.6.3　更好地支持并发的智能客户端 
18.7　本章小结 18.8　延伸阅读 