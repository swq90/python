会员 boat（727442652@qq.com） 专享 尊重版权
版权声明 O'Reilly Media, Inc. 介绍 业界评论 前言 目标读者 非目标读者 本书的结构 以实践为基础 硬件 杂谈：个人的一点看法 Python术语表 Python版本表 排版约定 使用代码示例 Safari? Books Online 联系我们 致谢 电子书 第一部分　序幕 第 1 章　Python 数据模型 1.1　一摞Python风格的纸牌 1.2　如何使用特殊方法 1.2.1　模拟数值类型 1.2.2　字符串表示形式 1.2.3　算术运算符 1.2.4　自定义的布尔值 1.3　特殊方法一览 1.4　为什么len不是普通方法 1.5　本章小结 1.6　延伸阅读 第二部分　数据结构 第 2 章　序列构成的数组 2.1　内置序列类型概览 2.2　列表推导和生成器表达式 2.2.1　列表推导和可读性 2.2.2　列表推导同filter和map的比较
2.2.3　笛卡儿积 2.2.4　生成器表达式 2.3　元组不仅仅是不可变的列表 2.3.1　元组和记录 2.3.2　元组拆包 2.3.3　嵌套元组拆包 2.3.4　具名元组 2.3.5　作为不可变列表的元组 2.4　切片 2.4.1　为什么切片和区间会忽略最后一个元素 2.4.2　对对象进行切片 2.4.3　多维切片和省略 2.4.4　给切片赋值 2.5　对序列使用+和* 建立由列表组成的列表 2.6　序列的增量赋值 一个关于+=的谜题 2.7　list.sort方法和内置函数sorted 2.8　用bisect来管理已排序的序列 2.8.1　用bisect来搜索 2.8.2　用bisect.insort插入新元素 2.9　当列表不是首选时 2.9.1　数组 2.9.2　内存视图 2.9.3　NumPy和SciPy 2.9.4　双向队列和其他形式的队列 2.10　本章小结 2.11　延伸阅读 第 3 章　字典和集合 3.1　泛映射类型 3.2　字典推导 3.3　常见的映射方法 用setdefault处理找不到的键 3.4　映射的弹性键查询 3.4.1　defaultdict：处理找不到的键的一个选择 3.4.2　特殊方法__missing__
3.5　字典的变种 3.6　子类化UserDict 3.7　不可变映射类型 3.8　集合论 3.8.1　集合字面量 3.8.2　集合推导 3.8.3　集合的操作 3.9　dict和set的背后 3.9.1　一个关于效率的实验 3.9.2　字典中的散列表 3.9.3　dict的实现及其导致的结果 3.9.4　set的实现以及导致的结果 3.10　本章小结 3.11　延伸阅读 第 4 章　文本和字节序列 4.1　字符问题 4.2　字节概要 结构体和内存视图 4.3　基本的编解码器 4.4　了解编解码问题 4.4.1　处理UnicodeEncodeError 4.4.2　处理UnicodeDecodeError 4.4.3　使用预期之外的编码加载模块时抛出的SyntaxError 4.4.4　如何找出字节序列的编码 4.4.5　BOM：有用的鬼符 4.5　处理文本文件 编码默认值：一团糟 4.6　为了正确比较而规范化Unicode字符串 4.6.1　大小写折叠 4.6.2　规范化文本匹配实用函数 4.6.3　极端“规范化”：去掉变音符号 4.7　Unicode文本排序 使用Unicode排序算法排序 4.8　Unicode数据库 4.9　支持字符串和字节序列的双模式API 4.9.1　正则表达式中的字符串和字节序列
4.9.2　os函数中的字符串和字节序列 4.10　本章小结 4.11　延伸阅读 第三部分　把函数视作对象 第 5 章　一等函数 5.1　把函数视作对象 5.2　高阶函数 map、filter和reduce的现代替代品 5.3　匿名函数 5.4　可调用对象 5.5　用户定义的可调用类型 5.6　函数内省 5.7　从定位参数到仅限关键字参数 5.8　获取关于参数的信息 5.9　函数注解 5.10　支持函数式编程的包 5.10.1　operator模块 5.10.2　使用functools.partial冻结参数 5.11　本章小结 5.12　延伸阅读 第 6 章　使用一等函数实现设计模式 6.1　案例分析：重构“策略”模式 6.1.1　经典的“策略”模式 6.1.2　使用函数实现“策略”模式 6.1.3　选择最佳策略：简单的方式 6.1.4　找出模块中的全部策略 6.2　“命令”模式 6.3　本章小结 6.4　延伸阅读 第 7 章　函数装饰器和闭包 7.1　装饰器基础知识 7.2　Python何时执行装饰器 7.3　使用装饰器改进“策略”模式 7.4　变量作用域规则 7.5　闭包 7.6　nonlocal声明
7.7　实现一个简单的装饰器 工作原理 7.8　标准库中的装饰器 7.8.1　使用functools.lru_cache做备忘 7.8.2　单分派泛函数 7.9　叠放装饰器 7.10　参数化装饰器 7.10.1　一个参数化的注册装饰器 7.10.2　参数化clock装饰器 7.11　本章小结 7.12　延伸阅读 第四部分　面向对象惯用法 第 8 章　对象引用、可变性和垃圾回收 8.1　变量不是盒子 8.2　标识、相等性和别名 8.2.1　在==和is之间选择 8.2.2　元组的相对不可变性 8.3　默认做浅复制 为任意对象做深复制和浅复制 8.4　函数的参数作为引用时 8.4.1　不要使用可变类型作为参数的默认值 8.4.2　防御可变参数 8.5　del和垃圾回收 8.6　弱引用 8.6.1　WeakValueDictionary简介 8.6.2　弱引用的局限 8.7　Python对不可变类型施加的把戏 8.8　本章小结 8.9　延伸阅读 第 9 章　符合Python风格的对象 9.1　对象表示形式 9.2　再谈向量类 9.3　备选构造方法 9.4　classmethod与staticmethod 9.5　格式化显示 9.6　可散列的Vector2d
9.7　Python的私有属性和“受保护的”属性 9.8　使用 __slots__ 类属性节省空间 __slots__ 的问题 9.9　覆盖类属性 9.10　本章小结 9.11　延伸阅读 第 10 章　序列的修改、散列和切片 10.1　Vector类：用户定义的序列类型 10.2　Vector类第1版：与Vector2d类兼容 10.3　协议和鸭子类型 10.4　Vector类第2版：可切片的序列 10.4.1　切片原理 10.4.2　能处理切片的__getitem__方法 10.5　Vector类第3版：动态存取属性 10.6　Vector类第4版：散列和快速等值测试 10.7　Vector类第5版：格式化 10.8　本章小结 10.9　延伸阅读 第 11 章　接口：从协议到抽象基类 11.1　Python文化中的接口和协议 11.2　Python喜欢序列 11.3　使用猴子补丁在运行时实现协议 11.4　Alex Martelli的水禽 11.5　定义抽象基类的子类 11.6　标准库中的抽象基类 11.6.1　collections.abc模块中的抽象基类 11.6.2　抽象基类的数字塔 11.7　定义并使用一个抽象基类 11.7.1　抽象基类句法详解 11.7.2　定义Tombola抽象基类的子类 11.7.3　Tombola的虚拟子类 11.8　Tombola子类的测试方法 11.9　Python使用register的方式 11.10　鹅的行为有可能像鸭子 11.11　本章小结 11.12　延伸阅读
第 12 章　继承的优缺点 12.1　子类化内置类型很麻烦 12.2　多重继承和方法解析顺序 12.3　多重继承的真实应用 12.4　处理多重继承 Tkinter好的、不好的和令人厌恶的方面 12.5　一个现代示例：Django通用视图中的混入 12.6　本章小结 12.7　延伸阅读 第 13 章　正确重载运算符 13.1　运算符重载基础 13.2　一元运算符 13.3　重载向量加法运算符+ 13.4　重载标量乘法运算符* 13.5　众多比较运算符 13.6　增量赋值运算符 13.7　本章小结 13.8　延伸阅读 第五部分　控制流程 第 14 章　可迭代的对象、迭代器和生成器 14.1　Sentence类第1版：单词序列 序列可以迭代的原因：iter函数 14.2　可迭代的对象与迭代器的对比 14.3　Sentence类第2版：典型的迭代器 把Sentence变成迭代器：坏主意 14.4　Sentence类第3版：生成器函数 生成器函数的工作原理 14.5　Sentence类第4版：惰性实现 14.6　Sentence类第5版：生成器表达式 14.7　何时使用生成器表达式 14.8　另一个示例：等差数列生成器 使用itertools模块生成等差数列 14.9　标准库中的生成器函数 14.10　Python 3.3中新出现的句法：yield from 14.11　可迭代的归约函数 14.12　深入分析iter函数
14.13　案例分析：在数据库转换工具中使用生成器 14.14　把生成器当成协程 14.15　本章小结 14.16　延伸阅读 第 15 章　上下文管理器和 else 块 15.1　先做这个，再做那个：if语句之外的else块 15.2　上下文管理器和with块 15.3　contextlib模块中的实用工具 15.4　使用@contextmanager 15.5　本章小结 15.6　延伸阅读 第 16 章　协程 16.1　生成器如何进化成协程 16.2　用作协程的生成器的基本行为 16.3　示例：使用协程计算移动平均值 16.4　预激协程的装饰器 16.5　终止协程和异常处理 16.6　让协程返回值 16.7　使用yield from 16.8　yield from的意义 16.9　使用案例：使用协程做离散事件仿真 16.9.1　离散事件仿真简介 16.9.2　出租车队运营仿真 16.10　本章小结 16.11　延伸阅读 第 17 章　使用期物处理并发 17.1　示例：网络下载的三种风格 17.1.1　依序下载的脚本 17.1.2　使用concurrent.futures模块下载 17.1.3　期物在哪里 17.2　阻塞型I/O和GIL 17.3　使用concurrent.futures模块启动进程 17.4　实验Executor.map方法 17.5　显示下载进度并处理错误 17.5.1　flags2系列示例处理错误的方式 17.5.2　使用futures.as_completed函数
17.5.3　线程和多进程的替代方案 17.6　本章小结 17.7　延伸阅读 第 18 章　使用 asyncio 包处理并发 18.1　线程与协程对比 18.1.1　asyncio.Future：故意不阻塞 18.1.2　从期物、任务和协程中产出 18.2　使用asyncio和aiohttp包下载 18.3　避免阻塞型调用 18.4　改进asyncio下载脚本 18.4.1　使用asyncio.as_completed函数 18.4.2　使用Executor对象，防止阻塞事件循环 18.5　从回调到期物和协程 每次下载发起多次请求 18.6　使用asyncio包编写服务器 18.6.1　使用asyncio包编写TCP服务器 18.6.2　使用aiohttp包编写Web服务器 18.6.3　更好地支持并发的智能客户端 18.7　本章小结 18.8　延伸阅读 第六部分　元编程 第 19 章　动态属性和特性 19.1　使用动态属性转换数据 19.1.1　使用动态属性访问JSON类数据 19.1.2　处理无效属性名 19.1.3　使用 __new__ 方法以灵活的方式创建对象 19.1.4　使用shelve模块调整OSCON数据源的结构 19.1.5　使用特性获取链接的记录 19.2　使用特性验证属性 19.2.1　LineItem类第1版：表示订单中商品的类 19.2.2　LineItem类第2版：能验证值的特性 19.3　特性全解析 19.3.1　特性会覆盖实例属性 19.3.2　特性的文档 19.4　定义一个特性工厂函数 19.5　处理属性删除操作
19.6　处理属性的重要属性和函数 19.6.1　影响属性处理方式的特殊属性 19.6.2　处理属性的内置函数 19.6.3　处理属性的特殊方法 19.7　本章小结 19.8　延伸阅读 第 20 章　属性描述符 20.1　描述符示例：验证属性 20.1.1　LineItem类第3版：一个简单的描述符 20.1.2　LineItem类第4版：自动获取储存属性的名称 20.1.3　LineItem类第5版：一种新型描述符 20.2　覆盖型与非覆盖型描述符对比 20.2.1　覆盖型描述符 20.2.2　没有 __get__ 方法的覆盖型描述符 20.2.3　非覆盖型描述符 20.2.4　在类中覆盖描述符 20.3　方法是描述符 20.4　描述符用法建议 20.5　描述符的文档字符串和覆盖删除操作 20.6　本章小结 20.7　延伸阅读 第 21 章　类元编程 21.1　类工厂函数 21.2　定制描述符的类装饰器 21.3　导入时和运行时比较 理解计算时间的练习 21.4　元类基础知识 理解元类计算时间的练习 21.5　定制描述符的元类 21.6　元类的特殊方法 __prepare__ 21.7　类作为对象 21.8　本章小结 21.9　延伸阅读 结语 延伸阅读 附录 A　辅助脚本
A.1　第3章：in运算符的性能测试 A.2　第3章：比较散列后的位模式 A.3　第9章：有或没有 __slots__ 时，RAM的用量 A.4　第14章：转换数据库的isis2json.py脚本 A.5　第16章：出租车队离散事件仿真 A.6　第17章：加密示例 A.7　第17章：flags2系列HTTP客户端示例 A.8　第19章：处理OSCON日程表的脚本和测试 Python 术语表 作者简介 关于封面
